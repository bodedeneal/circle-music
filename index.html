<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bounce Arena â€” with sound and recording</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, Arial, sans-serif;
      background: #111;
      color: #f2f2f2;
      display: grid;
      place-items: center;
      min-height: 100dvh;
    }
    .wrap {
      width: min(900px, 95vw);
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      background: #0b1323;
      border: 2px solid #3b4350;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(2, auto) 1fr;
      gap: .75rem 1rem;
      align-items: center;
      margin-top: 12px;
    }
    .controls > * {
      min-width: 0;
    }
    .row {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    button, input[type="file"], label, a.button {
      font: inherit;
      padding: .55rem .8rem;
      border-radius: 8px;
      border: 1px solid #3b4350;
      background: #1a2234;
      color: #e8ecf3;
      cursor: pointer;
    }
    button:disabled, a.button.disabled {
      opacity: .55;
      cursor: not-allowed;
    }
    a.button {
      text-decoration: none;
      display: inline-block;
    }
    input[type="checkbox"] {
      transform: translateY(1px);
    }
    small.hint {
      color: #9aa6b2;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="arena" width="900" height="540" aria-label="Bouncing ball arena"></canvas>

    <div class="controls">
      <div class="row">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <a id="downloadLink" class="button disabled" download="bounce.webm" aria-disabled="true">Download</a>
      </div>

      <div class="row">
        <label>
          <input type="checkbox" id="micToggle" />
          Use mic
        </label>
        <small class="hint">Recording includes canvas + sounds (+ mic if enabled)</small>
      </div>

      <div class="row" style="grid-column: 1 / -1">
        <label>
          Collision sound:
          <input type="file" id="collisionInput" accept="audio/*" />
        </label>
        <label>
          Background track:
          <input type="file" id="bgInput" accept="audio/*" />
        </label>
      </div>
    </div>
  </div>

  <script>
    // --- Canvas and animation state ---
    const canvas = document.getElementById('arena');
    const ctx = canvas.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadLink = document.getElementById('downloadLink');
    const collisionInput = document.getElementById('collisionInput');
    const bgInput = document.getElementById('bgInput');
    const micToggle = document.getElementById('micToggle');

    const W = canvas.width, H = canvas.height;
    const R = 14; // radius

    let ball = {
      x: W * 0.5,
      y: H * 0.5,
      vx: 680,    // faster speed as requested
      vy: 460,
      r: R
    };

    let running = false;
    let rafId = null;
    let lastTime = 0;
    let lastCollisionTime = 0;
    let hadCollision = false;

    // --- Audio graph: WebAudio mix to a single MediaStreamDestination ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioCtx();
    const mixOut = audioCtx.createMediaStreamDestination();

    // Monitor mix locally
    const monitorGain = audioCtx.createGain();
    monitorGain.gain.value = 1.0;
    monitorGain.connect(audioCtx.destination);

    // We'll route all sound sources to both monitor and mixOut
    function tee(node) {
      node.connect(monitorGain);
      node.connect(mixOut);
    }

    // Background track (MediaElementSource)
    const bgAudio = new Audio();
    bgAudio.loop = true;
    bgAudio.crossOrigin = 'anonymous';
    let bgSource = null;
    let bgGain = audioCtx.createGain();
    bgGain.gain.value = 0.8; // gentle
    tee(bgGain);

    function attachBgSource() {
      if (bgSource) {
        try { bgSource.disconnect(); } catch {}
      }
      bgSource = audioCtx.createMediaElementSource(bgAudio);
      bgSource.connect(bgGain);
    }

    // Collision sound (decoded buffer for low latency)
    let collisionBuffer = null;
    let hitGain = audioCtx.createGain();
    hitGain.gain.value = 0.9;
    tee(hitGain);

    function playHit() {
      lastCollisionTime = performance.now();
      hadCollision = true;

      if (collisionBuffer) {
        const src = audioCtx.createBufferSource();
        src.buffer = collisionBuffer;
        src.connect(hitGain);
        src.start();
      } else {
        // Fallback: quick blip if no file loaded
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.frequency.value = 540;
        g.gain.value = 0.0001;
        osc.connect(g);
        g.connect(hitGain);
        const t = audioCtx.currentTime;
        g.gain.exponentialRampToValueAtTime(0.6, t + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
        osc.start(t);
        osc.stop(t + 0.13);
      }
    }

    // Microphone
    let micStream = null;
    let micNode = null;
    let micGain = audioCtx.createGain();
    micGain.gain.value = 0.9;
    tee(micGain);

    async function enableMic(enable) {
      if (enable) {
        if (!micStream) {
          micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          micNode = audioCtx.createMediaStreamSource(micStream);
          micNode.connect(micGain);
        }
      } else {
        if (micNode) {
          try { micNode.disconnect(); } catch {}
          micNode = null;
        }
        if (micStream) {
          micStream.getTracks().forEach(t => t.stop());
          micStream = null;
        }
      }
    }

    micToggle.addEventListener('change', async (e) => {
      await audioCtx.resume();
      enableMic(e.target.checked).catch(console.error);
    });

    // Loaders for user files
    collisionInput.addEventListener('change', async () => {
      await audioCtx.resume();
      const file = collisionInput.files?.[0];
      if (!file) return;
      const ab = await file.arrayBuffer();
      collisionBuffer = await audioCtx.decodeAudioData(ab);
    });

    bgInput.addEventListener('change', async () => {
      await audioCtx.resume();
      const file = bgInput.files?.[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      bgAudio.src = url;
      if (!bgSource) attachBgSource();
      // Let it load before playing at start
    });

    // --- Recording: canvas video + mixed audio to MediaRecorder ---
    let recorder = null;
    let chunks = [];
    let recordedBlobUrl = null;

    function makeCombinedStream() {
      const fps = 60;
      const videoStream = canvas.captureStream(fps);
      const audioStream = mixOut.stream;
      const combined = new MediaStream([
        ...videoStream.getVideoTracks(),
        ...audioStream.getAudioTracks()
      ]);
      return combined;
    }

    function setupRecorder() {
      if (recorder && recorder.state !== 'inactive') {
        try { recorder.stop(); } catch {}
      }
      chunks = [];
      const stream = makeCombinedStream();
      let mt = 'video/webm;codecs=vp9,opus';
      if (!MediaRecorder.isTypeSupported(mt)) mt = 'video/webm;codecs=vp8,opus';
      if (!MediaRecorder.isTypeSupported(mt)) mt = 'video/webm';
      recorder = new MediaRecorder(stream, { mimeType: mt });
      recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = () => {
        if (recordedBlobUrl) URL.revokeObjectURL(recordedBlobUrl);
        const blob = new Blob(chunks, { type: recorder.mimeType || 'video/webm' });
        recordedBlobUrl = URL.createObjectURL(blob);
        downloadLink.href = recordedBlobUrl;
        downloadLink.classList.remove('disabled');
        downloadLink.setAttribute('aria-disabled', 'false');
      };
    }

    // --- Animation and physics ---
    function resetBall() {
      ball.x = W * 0.5;
      ball.y = H * 0.5;
      ball.vx = 680; // faster as requested
      ball.vy = 460;
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Arena styling
      ctx.strokeStyle = '#23314a';
      ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, W - 4, H - 4);

      // Ball
      const grd = ctx.createRadialGradient(ball.x - 6, ball.y - 6, 2, ball.x, ball.y, ball.r + 6);
      grd.addColorStop(0, '#3ec5ff');
      grd.addColorStop(1, '#0da0ff');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();

      // subtle glow
      ctx.shadowColor = '#0da0ff55';
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.strokeStyle = '#63d2ff22';
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function step(dt) {
      // Integrate
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Collisions: fire exactly when touching edge; clamp to avoid tunneling
      const r = ball.r;

      if (ball.x - r <= 0) {
        ball.x = r;
        if (ball.vx < 0) {
          ball.vx = -ball.vx;
          playHit();
        }
      } else if (ball.x + r >= W) {
        ball.x = W - r;
        if (ball.vx > 0) {
          ball.vx = -ball.vx;
          playHit();
        }
      }

      if (ball.y - r <= 0) {
        ball.y = r;
        if (ball.vy < 0) {
          ball.vy = -ball.vy;
          playHit();
        }
      } else if (ball.y + r >= H) {
        ball.y = H - r;
        if (ball.vy > 0) {
          ball.vy = -ball.vy;
          playHit();
        }
      }
    }

    function animate(ts) {
      if (!lastTime) lastTime = ts;
      const dt = Math.min(0.033, (ts - lastTime) / 1000); // clamp to avoid huge steps
      lastTime = ts;

      step(dt);
      draw();

      // Stop ~0.3s after the last collision ONLY if at least one collision occurred
      if (hadCollision && performance.now() - lastCollisionTime > 300) {
        stopAll();
        return;
      }

      rafId = requestAnimationFrame(animate);
    }

    // --- Control flow ---
    async function startAll() {
      await audioCtx.resume();

      // Enable mic if toggle is on (ignore if denied)
      if (micToggle.checked) {
        try { await enableMic(true); } catch (e) { console.warn('Mic unavailable', e); }
      }

      // Prepare recorder and start
      setupRecorder();
      try { recorder.start(100); } catch (e) { console.warn('Recorder start failed', e); }

      // Reset animation state
      resetBall();
      hadCollision = false;
      lastCollisionTime = performance.now(); // start a fresh window
      running = true;
      lastTime = 0;

      // Play background if loaded
      if (bgAudio.src) {
        try {
          if (!bgSource) attachBgSource();
          await bgAudio.play();
        } catch (e) { /* autoplay might be blocked until user gesture */ }
      }

      // UI
      startBtn.disabled = true;
      stopBtn.disabled = false;
      downloadLink.classList.add('disabled');
      downloadLink.setAttribute('aria-disabled', 'true');

      rafId = requestAnimationFrame(animate);
    }

    function stopAll() {
      if (!running) return;
      running = false;

      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      // Stop recording
      try { if (recorder && recorder.state === 'recording') recorder.stop(); } catch {}

      // Pause background audio
      try { bgAudio.pause(); } catch {}

      // UI
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    // Buttons
    startBtn.addEventListener('click', () => startAll());
    stopBtn.addEventListener('click', () => stopAll());

    // Accessibility: disable download link when empty
    downloadLink.addEventListener('click', (e) => {
      if (downloadLink.classList.contains('disabled')) e.preventDefault();
    });

    // Make sure audio graph is initialized on first interaction
    window.addEventListener('pointerdown', () => audioCtx.resume(), { once: true });
    window.addEventListener('keydown', () => audioCtx.resume(), { once: true });
  </script>
</body>
</html>
